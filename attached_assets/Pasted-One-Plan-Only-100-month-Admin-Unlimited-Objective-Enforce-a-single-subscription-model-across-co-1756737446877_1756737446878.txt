One Plan Only (100/month) + Admin Unlimited
Objective

Enforce a single subscription model across code, DB, and checkout.

Internal plan key: sselfie-studio

Public name: “Personal Brand Studio”

Price: €47/month

Monthly limit: 100 image generations

Admin (Sandra): unlimited (-1) — keep as-is

No FREE plan. If a user has no active Stripe subscription, they must be blocked at 0 and pushed to checkout.

Acceptance Criteria (must all be true)

Only two effective states exist:

sselfie-studio → limit 100 (active paying users)

Admin Sandra → limit -1 (unlimited)

Everyone else (no active sub) → limit 0 (blocked until checkout)

All paying users are on plan sselfie-studio with 100.

Stripe checkout always provisions sselfie-studio with 100.

All legacy plans (basic, pro, full-access, studio, free) are deprecated and auto-corrected at the edges.

Rate-limiter enforces: admin unlimited, payers 100, non-payers 0.

Daily integrity check alerts if anything drifts.

Step 1 — Single Source of Truth (Code)

Files (adjust paths if different):
server/config/plans.ts (or equivalent), server/services/usageService.ts, server/services/billing/stripe.ts

// server/config/plans.ts
export const PLANS = {
  sselfieStudio: {
    key: 'sselfie-studio',
    monthlyGenerations: 100,
    priceCents: 4700,
    publicName: 'Personal Brand Studio',
    description: '100 AI generations/month + Maya stylist',
  },
};

// No other plans. Hard-delete or dead-code any of: basic, pro, full-access, studio, free.

// server/services/usageService.ts
export function getMonthlyLimitForUser(user: {
  role?: string;
  plan?: string | null;
  monthly_generation_limit?: number | null;
  has_active_subscription?: boolean;
}) {
  // Admin always unlimited
  if (user.role === 'admin' || user.monthly_generation_limit === -1) return -1;

  // Must have an active subscription to generate
  if (!user.has_active_subscription || user.plan !== 'sselfie-studio') return 0;

  return PLANS.sselfieStudio.monthlyGenerations; // 100
}


If you don’t have has_active_subscription on the user, compute it at request time from Stripe/webhooks (see Step 3) and cache it on the user row.

Step 2 — UI/Copy Consistency (Frontend)

Everywhere: show one offer only: “Personal Brand Studio — €47/month — 100 photos/month.”

Remove/hide any references to free/other tiers.

CTA routes to checkout for sselfie-studio only.

If has_active_subscription === false, block generation UI and show a checkout gate.

Step 3 — Stripe Mapping (One Product/Price)

Ensure one Stripe Product + one recurring Price (€47/month).

Checkout success webhook (checkout.session.completed or invoice.paid) must set BOTH:

await db.users.update(userId, {
  plan: 'sselfie-studio',
  monthly_generation_limit: 100,
  has_active_subscription: true
});


Cancellation/expiration webhooks must flip:

await db.users.update(userId, {
  has_active_subscription: false,
  plan: null, // optional
  monthly_generation_limit: 0
});

Step 4 — Data Migration (Idempotent, Safe)

Replace with your admin email(s).

If you have a subscriptions table or a Stripe status view:

Treat users as paying only if they have an active Stripe subscription.

BEGIN;

-- 0) Normalize admin (Sandra) → unlimited
UPDATE users
SET role = 'admin',
    plan = 'sselfie-studio',
    monthly_generation_limit = -1,
    has_active_subscription = true
WHERE lower(email) IN ('sandra@yourdomain.com'); -- add any admin emails

-- 1) Paying users (active subs) → single plan 100
-- Adjust table/column names to your schema
UPDATE users u
SET plan = 'sselfie-studio',
    monthly_generation_limit = 100,
    has_active_subscription = true
FROM subscriptions s
WHERE u.id = s.user_id
  AND s.status IN ('active','trialing','past_due')  -- choose your "active" statuses
  AND (u.plan IS DISTINCT FROM 'sselfie-studio' OR u.monthly_generation_limit IS DISTINCT FROM 100)
  AND lower(u.email) NOT IN ('sandra@yourdomain.com');

-- 2) Everyone else (no active sub) → blocked (0)
UPDATE users u
SET plan = NULL,
    monthly_generation_limit = 0,
    has_active_subscription = false
WHERE NOT EXISTS (
  SELECT 1
  FROM subscriptions s
  WHERE s.user_id = u.id
    AND s.status IN ('active','trialing','past_due')
)
AND lower(u.email) NOT IN ('sandra@yourdomain.com');

-- 3) Kill legacy plan limits on any stragglers
UPDATE users
SET plan = 'sselfie-studio',
    monthly_generation_limit = 100,
    has_active_subscription = true
WHERE plan IN ('basic','pro','full-access','studio','free','sselfie-studio')
  AND monthly_generation_limit NOT IN (100, -1)
  AND lower(email) NOT IN ('sandra@yourdomain.com')
  AND has_active_subscription = true;

COMMIT;


If you do NOT have a subscriptions table:

Temporarily infer payers by presence of stripe_customer_id + any current plan not null. Then fix after first webhook sweep.

BEGIN;

-- Admin stays unlimited
UPDATE users
SET role = 'admin',
    plan = 'sselfie-studio',
    monthly_generation_limit = -1,
    has_active_subscription = true
WHERE lower(email) IN ('sandra@yourdomain.com');

-- Heuristic: users with stripe_customer_id → paying (until webhook backfill confirms)
UPDATE users
SET plan = 'sselfie-studio',
    monthly_generation_limit = 100,
    has_active_subscription = true
WHERE stripe_customer_id IS NOT NULL
  AND lower(email) NOT IN ('sandra@yourdomain.com');

-- Everyone else blocked (0)
UPDATE users
SET plan = NULL,
    monthly_generation_limit = 0,
    has_active_subscription = false
WHERE stripe_customer_id IS NULL
  AND lower(email) NOT IN ('sandra@yourdomain.com');

COMMIT;


Verify:

SELECT plan, monthly_generation_limit, has_active_subscription, COUNT(*)
FROM users
GROUP BY plan, monthly_generation_limit, has_active_subscription
ORDER BY plan NULLS FIRST;


Expected buckets:

NULL | 0 | false (no active sub → blocked)

'sselfie-studio' | 100 | true (paying)

'sselfie-studio' | -1 | true (admin only)

Step 5 — Edge Auto-Correction (Middleware)

On every auth’d request, normalize legacy users:

const legacy = new Set(['basic','pro','full-access','studio','free']);
if (legacy.has(user.plan as string)) {
  const isActive = await isStripeActive(user.id); // your helper
  await db.users.update(user.id, {
    plan: isActive ? 'sselfie-studio' : null,
    monthly_generation_limit: isActive ? 100 : 0,
    has_active_subscription: isActive
  });
}

Step 6 — Rate Limiting
// generationService.ts
const limit = getMonthlyLimitForUser(user); // -1, 100, or 0
if (limit === -1) return allow();
if (limit === 0) return deny('You need an active subscription to generate images.');
if (used >= limit) return deny('You’ve reached your 100 images for this month.');
return allow();

Step 7 — Monthly Reset

Reset counters for paid users only (leave admin untouched, blocked users stay 0):

UPDATE users
SET generations_used_this_month = 0
WHERE plan = 'sselfie-studio'
  AND monthly_generation_limit = 100;


Schedule: 1st of month, 00:00 UTC (cron).

Step 8 — Daily Integrity Check (Alert if drift)
SELECT id, email, plan, monthly_generation_limit, has_active_subscription
FROM users
WHERE
  -- only allowed combos:
  NOT (
    (plan IS NULL AND monthly_generation_limit = 0 AND has_active_subscription = false)
    OR (plan = 'sselfie-studio' AND monthly_generation_limit = 100 AND has_active_subscription = true)
    OR (plan = 'sselfie-studio' AND monthly_generation_limit = -1 AND has_active_subscription = true) -- admin
  );


If any rows return, log + notify (Slack webhook) and auto-remediate if safe.

Step 9 — Tests

Unit: getMonthlyLimitForUser returns -1/100/0 as expected.

Integration: webhooks flip has_active_subscription true/false and set plan/limits accordingly.

Migration: seeding messy users ends in only the 3 allowed states.

Rate limit: admin unlimited, payers capped at 100, non-payers blocked.

Edge correction: legacy plan users normalized on first request.

One-Time Fixes from Audit (explicit)

Users on sselfie-studio with 300 → set to 100 (if active).

studio with 500 (Erla) → move to sselfie-studio 100 (if active).

pro, full-access, basic, free →

If active Stripe sub → sselfie-studio 100

Else → blocked (0) + force checkout.