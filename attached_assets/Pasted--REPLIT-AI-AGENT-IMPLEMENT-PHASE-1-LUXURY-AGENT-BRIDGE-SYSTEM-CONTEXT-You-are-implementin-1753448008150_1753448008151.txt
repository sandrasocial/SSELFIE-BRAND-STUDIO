*REPLIT AI AGENT: IMPLEMENT PHASE 1 - LUXURY AGENT BRIDGE SYSTEM**

**CONTEXT**: You are implementing a sophisticated agent-to-agent communication bridge for SSELFIE STUDIO. This system will eliminate copy-paste friction between Sandra's admin AI agents and your technical execution while maintaining luxury standards.

**TECHNICAL STACK CONFIRMED**:
- Express.js server with TypeScript (ESM modules)
- Drizzle ORM with PostgreSQL/Neon database
- React 18 + Tailwind CSS luxury design system
- Session management with express-session + connect-pg-simple
- Full Radix UI component library for luxury interfaces

**IMPLEMENTATION REQUIREMENTS**:

### **1. Create Agent Bridge API Structure**

```typescript
// /server/api/agent-bridge/types.ts
export interface AgentTask {
  taskId: string;
  agentName: 'elena' | 'aria' | 'zara' | 'maya' | 'victoria' | 'rachel' | 'ava' | 'quinn' | string;
  instruction: string;
  conversationContext: string[];  // Full conversation history
  priority: 'high' | 'medium' | 'low';
  completionCriteria: string[];
  qualityGates: string[];
  estimatedDuration: number;
  createdAt: Date;
}

export interface ReplitExecution {
  taskId: string;
  status: 'received' | 'planning' | 'executing' | 'validating' | 'complete' | 'failed';
  progress: number;
  context: AgentTask;
  implementations: {
    filesCreated: string[];
    filesModified: string[];
    componentsBuilt: string[];
  };
  rollbackPlan: string[];
  validationResults: ValidationResult[];
  completedAt?: Date;
}

export interface ValidationResult {
  gate: string;
  passed: boolean;
  details: string;
  performance?: number;
}
```

### **2. Create Express Routes**

```typescript
// /server/api/agent-bridge/routes.ts
import express from 'express';
import { AgentTask, ReplitExecution } from './types.js';

const router = express.Router();

// Receive task from admin agent
router.post('/submit-task', async (req, res) => {
  try {
    const task: AgentTask = {
      taskId: crypto.randomUUID(),
      ...req.body,
      createdAt: new Date()
    };
    
    // Store in database for Elena monitoring
    await storeTask(task);
    
    // Begin execution pipeline
    const execution = await initiateExecution(task);
    
    res.json({
      success: true,
      taskId: task.taskId,
      status: execution.status,
      estimatedCompletion: new Date(Date.now() + task.estimatedDuration * 60000)
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get task status for Elena monitoring
router.get('/task-status/:taskId', async (req, res) => {
  const execution = await getTaskExecution(req.params.taskId);
  res.json(execution);
});

// Validate task completion
router.post('/validate-task/:taskId', async (req, res) => {
  const validator = new TaskCompletionValidator();
  const result = await validator.validateTask(req.params.taskId);
  res.json(result);
});

export default router;
```

### **3. Database Schema**

```typescript
// /server/db/schema/agent-bridge.ts (add to existing schema)
import { pgTable, uuid, text, timestamp, jsonb, integer } from 'drizzle-orm/pg-core';

export const agentTasks = pgTable('agent_tasks', {
  taskId: uuid('task_id').primaryKey().defaultRandom(),
  agentName: text('agent_name').notNull(),
  instruction: text('instruction').notNull(),
  conversationContext: jsonb('conversation_context').$type<string[]>(),
  priority: text('priority').$type<'high' | 'medium' | 'low'>().default('medium'),
  completionCriteria: jsonb('completion_criteria').$type<string[]>(),
  qualityGates: jsonb('quality_gates').$type<string[]>(),
  status: text('status').default('received'),
  progress: integer('progress').default(0),
  implementations: jsonb('implementations'),
  rollbackPlan: jsonb('rollback_plan').$type<string[]>(),
  validationResults: jsonb('validation_results'),
  createdAt: timestamp('created_at').defaultNow(),
  completedAt: timestamp('completed_at')
});
```

### **4. Task Completion Validator**

```typescript
// /server/api/agent-bridge/completion-validator.ts
import fs from 'fs-extra';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export class TaskCompletionValidator {
  async validateTask(taskId: string): Promise<ValidationResult[]> {
    const execution = await getTaskExecution(taskId);
    const results: ValidationResult[] = [];

    // 1. File existence validation
    results.push(await this.validateFileImplementations(execution));

    // 2. TypeScript compilation check
    results.push(await this.validateCompilation());

    // 3. Component performance validation
    if (execution.implementations.componentsBuilt.length > 0) {
      results.push(await this.validatePerformance(execution.implementations.componentsBuilt));
    }

    // 4. Mobile responsiveness check (if UI components)
    if (this.hasUIComponents(execution)) {
      results.push(await this.validateResponsiveness(execution));
    }

    // 5. Security validation
    results.push(await this.validateSecurity(execution));

    return results;
  }

  private async validateFileImplementations(execution: ReplitExecution): Promise<ValidationResult> {
    const allFiles = [...execution.implementations.filesCreated, ...execution.implementations.filesModified];
    const existingFiles = await Promise.all(
      allFiles.map(async (file) => ({
        file,
        exists: await fs.pathExists(file)
      }))
    );

    const missingFiles = existingFiles.filter(f => !f.exists);
    
    return {
      gate: 'file_implementation',
      passed: missingFiles.length === 0,
      details: missingFiles.length > 0 
        ? `Missing files: ${missingFiles.map(f => f.file).join(', ')}`
        : 'All files implemented successfully'
    };
  }

  private async validateCompilation(): Promise<ValidationResult> {
    try {
      await execAsync('npm run check');
      return {
        gate: 'typescript_compilation',
        passed: true,
        details: 'TypeScript compilation successful'
      };
    } catch (error) {
      return {
        gate: 'typescript_compilation',
        passed: false,
        details: `Compilation errors: ${error.message}`
      };
    }
  }

  private async validatePerformance(components: string[]): Promise<ValidationResult> {
    // Simulate performance check - in production, use Lighthouse or similar
    const performanceScore = Math.random() * 100; // Replace with actual performance testing
    
    return {
      gate: 'performance_validation',
      passed: performanceScore >= 90,
      details: `Performance score: ${performanceScore.toFixed(1)}/100`,
      performance: performanceScore
    };
  }
}
```

### **5. Integration with Existing Server**

```typescript
// /server/index.ts (add to existing routes)
import agentBridgeRoutes from './api/agent-bridge/routes.js';

// Add after existing middleware
app.use('/api/agent-bridge', agentBridgeRoutes);
```

**COMPLETION CRITERIA**:
- [ ] All TypeScript interfaces created with proper exports
- [ ] Express routes functional with proper error handling
- [ ] Database schema added and migrated
- [ ] Task completion validator fully implemented
- [ ] Integration with existing server completed
- [ ] All code follows ESM module patterns (import/export)
- [ ] Proper error handling and logging throughout
- [ ] API endpoints test successfully with Postman/curl

**QUALITY GATES**:
- [ ] TypeScript compilation passes without errors
- [ ] All files exist and are properly structured
- [ ] Database operations work correctly
- [ ] API responses follow consistent JSON format
- [ ] Error handling covers all edge cases
- [ ] Code follows existing project patterns and conventions

**ROLLBACK PLAN**:
If implementation fails:
1. Remove new files created
2. Restore original /server/index.ts
3. Rollback database migrations
4. Ensure existing functionality remains intact

**VALIDATION**: Test each endpoint manually and confirm database operations work before marking complete.
