/**
 * WORKFLOW VISUALIZATION
 * Real-time visualization of agent workflows and dependencies
 * Generated by Victoria - The BUILD Feature Mastermind
 */

export interface WorkflowNode {
  id: string;
  type: 'agent' | 'task' | 'service' | 'checkpoint';
  name: string;
  status: 'idle' | 'working' | 'completed' | 'error' | 'blocked';
  position: { x: number; y: number };
  metadata: Record<string, any>;
}

export interface WorkflowEdge {
  id: string;
  source: string;
  target: string;
  type: 'dependency' | 'communication' | 'data-flow';
  status: 'active' | 'inactive' | 'error';
  weight: number;
}

export interface WorkflowLayout {
  nodes: WorkflowNode[];
  edges: WorkflowEdge[];
  groups: WorkflowGroup[];
}

export interface WorkflowGroup {
  id: string;
  name: string;
  nodeIds: string[];
  color: string;
}

export class WorkflowVisualizer {
  private currentLayout: WorkflowLayout;
  private updateListeners: Set<(layout: WorkflowLayout) => void> = new Set();
  private animationFrame: number | null = null;

  constructor() {
    this.currentLayout = {
      nodes: [],
      edges: [],
      groups: []
    };
  }

  async render(): Promise<void> {
    console.log('ðŸ“Š WORKFLOW VISUALIZATION: Initializing real-time visualization...');
    this.setupDefaultLayout();
    this.startRealTimeUpdates();
  }

  private setupDefaultLayout(): void {
    // Create agent nodes
    const agents = ['elena', 'aria', 'maya', 'victoria', 'zara', 'olga'];
    
    agents.forEach((agentId, index) => {
      const angle = (index / agents.length) * 2 * Math.PI;
      const radius = 200;
      
      this.currentLayout.nodes.push({
        id: agentId,
        type: 'agent',
        name: agentId.charAt(0).toUpperCase() + agentId.slice(1),
        status: 'idle',
        position: {
          x: Math.cos(angle) * radius + 300,
          y: Math.sin(angle) * radius + 300
        },
        metadata: {
          role: this.getAgentRole(agentId),
          lastActivity: new Date().toISOString()
        }
      });
    });

    // Create coordination hub
    this.currentLayout.nodes.push({
      id: 'coordination-hub',
      type: 'service',
      name: 'Coordination Hub',
      status: 'working',
      position: { x: 300, y: 300 },
      metadata: {
        type: 'orchestration'
      }
    });

    // Create edges between agents and hub
    agents.forEach(agentId => {
      this.currentLayout.edges.push({
        id: `${agentId}-hub`,
        source: agentId,
        target: 'coordination-hub',
        type: 'communication',
        status: 'active',
        weight: 1
      });
    });

    // Create agent groups
    this.currentLayout.groups.push({
      id: 'frontend-group',
      name: 'Frontend',
      nodeIds: ['aria', 'victoria'],
      color: '#3b82f6'
    });

    this.currentLayout.groups.push({
      id: 'backend-group',
      name: 'Backend',
      nodeIds: ['zara', 'maya'],
      color: '#10b981'
    });

    this.currentLayout.groups.push({
      id: 'coordination-group',
      name: 'Coordination',
      nodeIds: ['elena', 'olga'],
      color: '#f59e0b'
    });
  }

  private getAgentRole(agentId: string): string {
    const roles: Record<string, string> = {
      'elena': 'Project Coordination',
      'aria': 'UX/UI Design',
      'maya': 'Technical Optimization',
      'victoria': 'Integration Flows',
      'zara': 'Backend Architecture',
      'olga': 'Organization & Documentation'
    };
    return roles[agentId] || 'Unknown';
  }

  updateAgentStatus(agentId: string, status: WorkflowNode['status'], metadata?: Record<string, any>): void {
    const node = this.currentLayout.nodes.find(n => n.id === agentId);
    if (node) {
      node.status = status;
      if (metadata) {
        node.metadata = { ...node.metadata, ...metadata };
      }
      this.notifyListeners();
    }
  }

  addTaskNode(taskId: string, assignedAgent: string, taskName: string): void {
    const agentNode = this.currentLayout.nodes.find(n => n.id === assignedAgent);
    if (!agentNode) return;

    // Position task near assigned agent
    const taskNode: WorkflowNode = {
      id: taskId,
      type: 'task',
      name: taskName,
      status: 'working',
      position: {
        x: agentNode.position.x + (Math.random() - 0.5) * 100,
        y: agentNode.position.y + (Math.random() - 0.5) * 100
      },
      metadata: {
        assignedAgent,
        createdAt: new Date().toISOString()
      }
    };

    this.currentLayout.nodes.push(taskNode);

    // Add edge from agent to task
    this.currentLayout.edges.push({
      id: `${assignedAgent}-${taskId}`,
      source: assignedAgent,
      target: taskId,
      type: 'dependency',
      status: 'active',
      weight: 1
    });

    this.notifyListeners();
  }

  addDependency(sourceId: string, targetId: string, type: WorkflowEdge['type'] = 'dependency'): void {
    const edgeId = `${sourceId}-${targetId}`;
    
    // Check if edge already exists
    if (this.currentLayout.edges.find(e => e.id === edgeId)) {
      return;
    }

    this.currentLayout.edges.push({
      id: edgeId,
      source: sourceId,
      target: targetId,
      type,
      status: 'active',
      weight: 1
    });

    this.notifyListeners();
  }

  removeTask(taskId: string): void {
    // Remove task node
    this.currentLayout.nodes = this.currentLayout.nodes.filter(n => n.id !== taskId);
    
    // Remove related edges
    this.currentLayout.edges = this.currentLayout.edges.filter(
      e => e.source !== taskId && e.target !== taskId
    );

    this.notifyListeners();
  }

  addCheckpoint(checkpointId: string, description: string): void {
    const checkpointNode: WorkflowNode = {
      id: checkpointId,
      type: 'checkpoint',
      name: description,
      status: 'completed',
      position: {
        x: 600 + Math.random() * 200,
        y: 300 + Math.random() * 200
      },
      metadata: {
        timestamp: new Date().toISOString(),
        type: 'milestone'
      }
    };

    this.currentLayout.nodes.push(checkpointNode);
    this.notifyListeners();
  }

  onLayoutUpdate(listener: (layout: WorkflowLayout) => void): void {
    this.updateListeners.add(listener);
  }

  offLayoutUpdate(listener: (layout: WorkflowLayout) => void): void {
    this.updateListeners.delete(listener);
  }

  private notifyListeners(): void {
    this.updateListeners.forEach(listener => {
      try {
        listener({ ...this.currentLayout });
      } catch (error) {
        console.error('Error in workflow visualization listener:', error);
      }
    });
  }

  private startRealTimeUpdates(): void {
    const update = () => {
      // Simulate real-time updates
      this.updateMetrics();
      this.animationFrame = requestAnimationFrame(update);
    };

    this.animationFrame = requestAnimationFrame(update);
  }

  private updateMetrics(): void {
    // Update node positions for active tasks
    this.currentLayout.nodes.forEach(node => {
      if (node.type === 'task' && node.status === 'working') {
        // Add subtle animation to working tasks
        node.metadata.lastUpdate = new Date().toISOString();
      }
    });
  }

  getLayout(): WorkflowLayout {
    return { ...this.currentLayout };
  }

  destroy(): void {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }
    this.updateListeners.clear();
  }
}